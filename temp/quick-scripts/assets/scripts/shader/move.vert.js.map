{"version":3,"sources":["move.vert.js"],"names":["module","exports"],"mappings":";;;;;;AAAAA,OAAOC,OAAP","file":"move.vert.js","sourceRoot":"../../../../../assets/scripts/shader","sourcesContent":["module.exports =\n    `\n// attribute vec2 a_position;\nattribute vec4 a_position;\nattribute vec2 a_texCoord;\nuniform float ratio; //挤牌程度\nuniform float radius;\nuniform float width;\nuniform float height;\nuniform float rotation;\n\nuniform float offx;\nuniform float offy;\nuniform float rotationLc;\nvarying vec2 v_texCoord;\n\nvoid main()\n{\n    vec4 tmp_pos = vec4(0.0, 0.0, 0.0, 0.0);\n    if (0.0 <= rotation && rotation < 90.0) {\n        tmp_pos = vec4(a_position.x, a_position.y, 0.0, 1.0);\n    }\n    else if (90.0 == rotation) {\n        // tmp_pos = vec4(a_position.y, width-a_position.x, 0.0, 1.0);\n        tmp_pos = vec4(a_position.x, a_position.y, 0.0, 1.0);\n    }\n    \n    float halfPeri = radius * 3.14159; //半圆的弧长（radius为半径this.pokerHeight / 10）\n    float hr = height * ratio;  //挤了多少长度\n    // float hr = width * ratio;  //挤了多少长度\n    // float hr = 0.0;\n    // if (0.0 <= rotation && rotation < 90.0) {\n    //     hr = height * ratio;\n    // }\n    // else if (90.0 == rotation) {\n    //     hr = height * ratio;\n    // }\n    //一开始的挤\n    if(hr > 0.0 && hr <= halfPeri){\n        if (0.0 <= rotation && rotation < 90.0) {\n            if(tmp_pos.y < hr){\n                float rad = hr/ 3.14159; //小半径（以这个长度为半圆的圆的半径）\n                float arc = (hr-tmp_pos.y)/rad; //弧度,这段弧长对应的角度\n                tmp_pos.y = hr - sin(arc)*rad; //斜边为半径的三角形，计算这个点所在的Y轴位置\n                tmp_pos.z = rad * (1.0-cos(arc));\n            }\n        }\n        else if (90.0 == rotation) {\n            if(tmp_pos.x < hr){\n                float rad = hr/ 3.14159; //小半径（以这个长度为半圆的圆的半径）\n                float arc = (hr-tmp_pos.x)/rad; //弧度,这段弧长对应的角度\n                tmp_pos.x = hr - sin(arc)*rad; //斜边为半径的三角形，计算这个点所在的Y轴位置\n                tmp_pos.z = rad * (1.0-cos(arc));\n           }\n        }\n    }\n    //挤牌过程\n    if(hr > halfPeri){\n        if (0.0 <= rotation && rotation < 90.0) {\n            float straight = (hr - halfPeri)/2.0; //直的部分的长度\n            if(tmp_pos.y < straight){\n                tmp_pos.y = hr  - tmp_pos.y;\n                tmp_pos.z = radius * 2.0;\n            }\n            //已翻开的下面弯曲的部分\n            else if(tmp_pos.y < (straight + halfPeri)) {\n                float dy = halfPeri - (tmp_pos.y - straight);\n                float arc = dy/radius;\n                tmp_pos.y = hr - straight - sin(arc)*radius;\n                tmp_pos.z = radius * (1.0-cos(arc));\n            }\n        }\n        else if (90.0 == rotation) {\n            float straight = (hr - halfPeri)/2.0; //直的部分的长度\n            if(tmp_pos.x < straight){\n                tmp_pos.x = hr - tmp_pos.x;\n                tmp_pos.z = radius * 2.0;\n            }\n            //已翻开的下面弯曲的部分\n            else if(tmp_pos.x < (straight + halfPeri)) {\n                float dx = halfPeri - (tmp_pos.x - straight);\n                float arc = dx/radius;\n                tmp_pos.x = hr - straight - sin(arc)*radius;\n                tmp_pos.z = radius * (1.0-cos(arc));\n            }\n        }\n     }\n     //位置偏移的\n    float y1 = tmp_pos.y;\n    float z1 = tmp_pos.z;\n    float y2 = height;\n    float z2 = 0.0;\n    float sinRat = sin(rotationLc);\n    float cosRat = cos(rotationLc);\n    tmp_pos.y=(y1-y2)*cosRat-(z1-z2)*sinRat+y2;\n    tmp_pos.z=(z1-z2)*cosRat+(y1-y2)*sinRat+z2;\n    tmp_pos.y = tmp_pos.y - height/2.0*(1.0-cosRat);\n    tmp_pos += vec4(offx, offy, 0.0, 0.0);\n\n    gl_Position = CC_MVPMatrix * tmp_pos;\n    v_texCoord = vec2(1.0-a_texCoord.x, 1.0-a_texCoord.y);\n\n }\n\n`\n\n"]}