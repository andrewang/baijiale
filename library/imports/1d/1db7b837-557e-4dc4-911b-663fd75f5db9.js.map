{"version":3,"sources":["../../../../../assets/common/sharder/assets/common/sharder/ANT_Page.vert.js"],"names":["module","exports"],"mappings":";;;;;;AAAAA,OAAOC,OAAP,GAAkB,+BACjB,0BADiB,GAEjB,gCAFiB,GAGjB,gCAHiB,GAIjB,uBAJiB,GAMjB,mCANiB,GAOjB,iCAPiB,GAQjB,iEARiB,GAUjB,uCAViB,GAYjB,8BAZiB,GAajB,gCAbiB,GAejB,kCAfiB,GAgBjB,4CAhBiB,GAkBjB,gDAlBiB,GAoBjB,yEApBiB,GAqBjB,2CArBiB,GAsBb,uBAtBa,GAuBb,6BAvBa,GAwBb,KAxBa,GA2BjB,8DA3BiB,GA4BjB,sBA5BiB,GA6Bb,sCA7Ba,GA8BT,sCA9BS,GA+BT,oDA/BS,GAgCb,6CAhCa,GAiCb,KAjCa,GAmCjB,sCAnCiB,GAoCjB,4DApCiB,GAqCb,4DArCa,GAsCb,qCAtCa,GAuCT,0CAvCS,GAwCT,qCAxCS,GAyCT,0CAzCS,GA0CT,6GA1CS,GA2CT,uBA3CS,GA4Cb,KA5Ca,GA8CjB,sEA9CiB,GA+CjB,sEA/CiB,GAgDb,4EAhDa,GAkDb,0FAlDa,GAmDT,0CAnDS,GAoDb,KApDa,GAsDb,iDAtDa,GAwDT,gDAxDS,GAyDb,4BAzDa,GA2Db,2DA3Da,GA4Db,KA5Da,GA8DjB,4FA9DiB,GA+DjB,gDA/DiB,GAgEb,kCAhEa,GAiEb,mCAjEa,GAkET,0BAlES,GAoET,8DApES,GAqEb,4BArEa,GAsEb,4BAtEa,GAuEb,4BAvEa,GAwEb,uBAxEa,GAyEb,KAzEa,GA2EjB,yCA3EiB,GA4EjB,gDA5EiB,GA6Eb,sDA7Ea,GA8Eb,kGA9Ea,GA+Eb,2BA/Ea,GAgFb,iBAhFa,GAiFb,KAjFa,GAmFjB,8DAnFiB,GAoFjB,wEApFiB,GAqFb,sCArFa,GAuFb,iDAvFa,GAyFb,sEAzFa,GA0Fb,qDA1Fa,GA4Fb,6HA5Fa,GA6FT,6FA7FS,GA8Fb,4CA9Fa,GA+FT,iBA/FS,GAgGT,UAhGS,GAiGb,gBAjGa,GAmGT,iEAnGS,GAoGb,KApGa,GAsGjB,qBAtGiB,GAuGjB,0CAvGiB,GAwGb,0BAxGa,GAyGb,0BAzGa,GA2Gb,yBA3Ga,GA4Gb,YA5Ga,GA6GT,aA7GS,GA8GT,kBA9GS,GA+GT,MA/GS,GAiHb,mBAjHa,GAkHb,mBAlHa,GAoHb,0BApHa,GAqHb,YArHa,GAsHT,aAtHS,GAuHT,iBAvHS,GAwHT,MAxHS,GA0Hb,gDA1Ha,GA4Hb,wCA5Ha,GA8Hb,+BA9Ha,GA+HT,wDA/HS,GAgIT,WAhIS,GAiIT,KAjIS,GAmIT,8BAnIS,GAoIT,kDApIS,GAqIT,WArIS,GAsIb,KAtIa,GAwIb,sEAxIa,GA0Ib,gDA1Ia,GA2Ib,uFA3Ia,GA4Ib,iEA5Ia,GA6Ib,WA7Ia,GA8Ib,KA9Ia,GAgJb,qDAhJa,GAkJb,2EAlJa,GAmJT,kFAnJS,GAoJb,WApJa,GAqJT,KArJS,GAuJb,qCAvJa,GAyJb,oBAzJa,GA0Jb,mBA1Ja,GA2JT,yFA3JS,GA4Jb,4CA5Ja,GA6JT,iBA7JS,GA8JT,4CA9JS,GA+Jb,YA/Ja,GAgKb,gDAhKa,GAiKb,KAjKa,GAmKb,mEAnKa,GAqKb,6EArKa,GAsKb,uCAtKa,GAuKb,8CAvKa,GAwKjB,KAxKD","file":"ANT_Page.vert.js","sourceRoot":"../../../../../assets/common/sharder","sourcesContent":["module.exports  = \"precision mediump float;\\n\"\r\n+\"varying vec2 texCoord;\\n\"\r\n+\"uniform sampler2D sourceTex;\\n\"\r\n+\"uniform sampler2D targetTex;\\n\"\r\n+\"uniform float time;\\n\"\r\n\r\n+\"const float MIN_AMOUNT = -0.16;\\n\"\r\n+\"const float MAX_AMOUNT = 1.3;\\n\"\r\n+\"float amount = time * (MAX_AMOUNT - MIN_AMOUNT) + MIN_AMOUNT;\\n\"\r\n\r\n+\"const float PI = 3.141592653589793;\\n\"\r\n\r\n+\"const float scale = 512.0;\\n\"\r\n+\"const float sharpness = 3.0;\\n\"\r\n\r\n+\"float cylinderCenter = amount;\\n\"\r\n+\"float cylinderAngle = 2.0 * PI * amount;\\n\"\r\n\r\n+\"const float cylinderRadius = 1.0 / PI / 2.0;\\n\"\r\n\r\n+\"vec3 hitPoint(float hitAngle, float yc, vec3 point, mat3 rrotation) {\\n\"\r\n+\"float hitPoint = hitAngle / (2.0 * PI);\\n\"\r\n    +\"point.y = hitPoint;\\n\"\r\n    +\"return rrotation * point;\\n\"\r\n    +\"}\\n\"\r\n\r\n\r\n+\"vec4 antiAlias(vec4 color1, vec4 color2, float distance) {\\n\"\r\n+\"distance *= scale;\\n\"\r\n    +\"if (distance < 0.0) return color2;\\n\"\r\n        +\"if (distance > 2.0) return color1;\\n\"\r\n        +\"float dd = pow(1.0 - distance / 2.0, sharpness);\\n\"\r\n    +\"return ((color2 - color1) * dd) + color1;\\n\"\r\n    +\"}\\n\"\r\n\r\n+\"float distanceToEdge(vec3 point) {\\n\"\r\n+\"float dx = abs(point.x > 0.5 ? 1.0 - point.x : point.x);\\n\"\r\n    +\"float dy = abs(point.y > 0.5 ? 1.0 - point.y : point.y);\\n\"\r\n    +\"if (point.x < 0.0) dx = -point.x;\\n\"\r\n        +\"if (point.x > 1.0) dx = point.x - 1.0;\\n\"\r\n        +\"if (point.y < 0.0) dy = -point.y;\\n\"\r\n        +\"if (point.y > 1.0) dy = point.y - 1.0;\\n\"\r\n        +\"if ((point.x < 0.0 || point.x > 1.0) && (point.y < 0.0 || point.y > 1.0)) return sqrt(dx * dx + dy * dy);\\n\"\r\n        +\"return min(dx, dy);\\n\"\r\n    +\"}\\n\"\r\n\r\n+\"vec4 seeThrough(float yc, vec2 p, mat3 rotation, mat3 rrotation) {\\n\"\r\n+\"float hitAngle = PI - (acos(yc / cylinderRadius) - cylinderAngle);\\n\"\r\n    +\"vec3 point = hitPoint(hitAngle, yc, rotation * vec3(p, 1.0), rrotation);\\n\"\r\n\r\n    +\"if (yc <= 0.0 && (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0)) {\\n\"\r\n        +\"return texture2D(targetTex, texCoord);\\n\"\r\n    +\"}\\n\"\r\n\r\n    +\"if (yc > 0.0) return texture2D(sourceTex, p);\\n\"\r\n\r\n        +\"vec4 color = texture2D(sourceTex, point.xy);\\n\"\r\n    +\"vec4 tcolor = vec4(0.0);\\n\"\r\n\r\n    +\"return antiAlias(color, tcolor, distanceToEdge(point));\\n\"\r\n    +\"}\\n\"\r\n\r\n+\"vec4 seeThroughWithShadow(float yc, vec2 p, vec3 point, mat3 rotation, mat3 rrotation) {\\n\"\r\n+\"float shadow = distanceToEdge(point) * 30.0;\\n\"\r\n    +\"shadow = (1.0 - shadow) / 3.0;\\n\"\r\n    +\"if (shadow < 0.0) shadow = 0.0;\\n\"\r\n        +\"else shadow *= amount;\\n\"\r\n\r\n        +\"vec4 shadowColor = seeThrough(yc, p, rotation, rrotation);\\n\"\r\n    +\"shadowColor.r -= shadow;\\n\"\r\n    +\"shadowColor.g -= shadow;\\n\"\r\n    +\"shadowColor.b -= shadow;\\n\"\r\n    +\"return shadowColor;\\n\"\r\n    +\"}\\n\"\r\n\r\n+\"vec4 backside(float yc, vec3 point) {\\n\"\r\n+\"vec4 color = texture2D(sourceTex, point.xy);\\n\"\r\n    +\"float gray = (color.r + color.b + color.g) / 15.0;\\n\"\r\n    +\"gray += (8.0 / 10.0) * (pow(1.0 - abs(yc / cylinderRadius), 2.0 / 10.0) / 2.0 + (5.0 / 10.0));\\n\"\r\n    +\"color.rgb = vec3(gray);\\n\"\r\n    +\"return color;\\n\"\r\n    +\"}\\n\"\r\n\r\n+\"vec4 behindSurface(float yc, vec3 point, mat3 rrotation) {\\n\"\r\n+\"float shado = (1.0 - ((-cylinderRadius - yc) / amount * 7.0)) / 6.0;\\n\"\r\n    +\"shado *= 1.0 - abs(point.x - 0.5);\\n\"\r\n\r\n    +\"yc = (-cylinderRadius - cylinderRadius - yc);\\n\"\r\n\r\n    +\"float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;\\n\"\r\n    +\"point = hitPoint(hitAngle, yc, point, rrotation);\\n\"\r\n\r\n    +\"if (yc < 0.0 && point.x >= 0.0 && point.y >= 0.0 && point.x <= 1.0 && point.y <= 1.0 && (hitAngle < PI || amount > 0.5)){\\n\"\r\n        +\"shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / (71.0 / 100.0));\\n\"\r\n    +\"shado *= pow(-yc / cylinderRadius, 3.0);\\n\"\r\n        +\"shado *= 0.5;\\n\"\r\n        +\"} else\\n\"\r\n    +\"shado = 0.0;\\n\"\r\n\r\n        +\"return vec4(texture2D(targetTex, texCoord).rgb - shado, 1.0);\\n\"\r\n    +\"}\\n\"\r\n\r\n+\"void main(void) {\\n\"\r\n+\"const float angle = 30.0 * PI / 180.0;\\n\"\r\n    +\"float c = cos(-angle);\\n\"\r\n    +\"float s = sin(-angle);\\n\"\r\n\r\n    +\"mat3 rotation = mat3(\\n\"\r\n    +\"c, s, 0,\\n\"\r\n        +\"-s, c, 0,\\n\"\r\n        +\"0.12, 0.258, 1\\n\"\r\n        +\");\\n\"\r\n\r\n    +\"c = cos(angle);\\n\"\r\n    +\"s = sin(angle);\\n\"\r\n\r\n    +\"mat3 rrotation = mat3(\\n\"\r\n    +\"c, s, 0,\\n\"\r\n        +\"-s, c, 0,\\n\"\r\n        +\"0.15, -0.5, 1\\n\"\r\n        +\");\\n\"\r\n\r\n    +\"vec3 point = rotation * vec3(texCoord, 1.0);\\n\"\r\n\r\n    +\"float yc = point.y - cylinderCenter;\\n\"\r\n\r\n    +\"if (yc < -cylinderRadius) {\\n\"\r\n        +\" gl_FragColor = behindSurface(yc, point, rrotation);\\n\"\r\n        +\"return;\\n\"\r\n        +\"}\\n\"\r\n\r\n        +\"if (yc > cylinderRadius) {\\n\"\r\n        +\"gl_FragColor = texture2D(sourceTex, texCoord);\\n\"\r\n        +\"return;\\n\"\r\n    +\"}\\n\"\r\n\r\n    +\"float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;\\n\"\r\n\r\n    +\"float hitAngleMod = mod(hitAngle, 2.0 * PI);\\n\"\r\n    +\"if ((hitAngleMod > PI && amount < 0.5) || (hitAngleMod > PI/2.0 && amount < 0.0)) {\\n\"\r\n    +\"gl_FragColor = seeThrough(yc, texCoord, rotation, rrotation);\\n\"\r\n    +\"return;\\n\"\r\n    +\"}\\n\"\r\n\r\n    +\"point = hitPoint(hitAngle, yc, point, rrotation);\\n\"\r\n\r\n    +\"if (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0) {\\n\"\r\n        +\"gl_FragColor = seeThroughWithShadow(yc, texCoord, point, rotation, rrotation);\\n\"\r\n    +\"return;\\n\"\r\n        +\"}\\n\"\r\n\r\n    +\"vec4 color = backside(yc, point);\\n\"\r\n\r\n    +\"vec4 otherColor;\\n\"\r\n    +\"if (yc < 0.0) {\\n\"\r\n        +\"float shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / 0.71);\\n\"\r\n    +\"shado *= pow(-yc / cylinderRadius, 3.0);\\n\"\r\n        +\"shado *= 0.5;\\n\"\r\n        +\"otherColor = vec4(0.0, 0.0, 0.0, shado);\\n\"\r\n    +\"} else {\\n\"\r\n    +\"otherColor = texture2D(sourceTex, texCoord);\\n\"\r\n    +\"}\\n\"\r\n\r\n    +\"color = antiAlias(color, otherColor, cylinderRadius - abs(yc));\\n\"\r\n\r\n    +\"vec4 cl = seeThroughWithShadow(yc, texCoord, point, rotation, rrotation);\\n\"\r\n    +\"float dist = distanceToEdge(point);\\n\"\r\n    +\"gl_FragColor = antiAlias(color, cl, dist);\\n\"\r\n+\"}\\n\";"]}