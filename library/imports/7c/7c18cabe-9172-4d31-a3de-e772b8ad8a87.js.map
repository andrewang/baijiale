{"version":3,"sources":["../../../../../../assets/scripts/app/game/assets/scripts/app/game/jipai.js"],"names":[],"mappings":";;;;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","file":"jipai.js","sourceRoot":"../../../../../../assets/scripts/app/game","sourcesContent":["// var jipai_vert = require(\"jipai.vert\");\n// var jipai_frag = require(\"jipai.frag\");\n\n// cc.Class({\n//     extends: cc.Component,\n\n//     properties: {\n//         szBack : cc.SpriteFrame,\n//         szFont : cc.SpriteFrame,\n//     },\n\n//     onLoad: function () {\n\n//         //this._use();\n//         var scale = 1.0\n//         //创建牌的背面\n//         // var ret1 = this.getTextureAndRange(this.szBack)\n//         // var id1 = ret1[0]\n//         // var texRange1 = ret1[1]\n//         // var sz1 = ret1[2]\n//         // ret1 = this.initCardVertex(cc.size(sz1[0] * scale, sz1[1] * scale), texRange1, true)\n//         // var msh1 = ret1[0]\n//         // var nVerts1 = ret1[1]\n//         // //创建牌的正面\n//         // var ret2 = this.getTextureAndRange(this.szFont)\n//         // var id2 = ret2[0]\n//         // var texRange2 = ret2[1]\n//         // var sz2 = ret2[2]\n//         // ret2 = this.initCardVertex(cc.size(sz2[0] * scale, sz2[1] * scale), texRange2, false)\n//         // var msh2 = ret2[0]\n//         // var nVerts2 = ret2[1]\n        \n//         //搓牌的程度控制， 搓牌类似于通过一个圆柱滚动将牌粘着起来的效果。下面的参数就是滚动程度和圆柱半径\n//         // this._uniRatio = 0.0\n//         // this._uniRadius = sz1[0] * scale / math.pi;\n//     },\n\n//     _use: function () {\n//         this._program = new cc.GLProgram()\n//         this._program.initWithString(jipai_vert, jipai_frag)\n//         this._program.link()\n//         this._program.updateUniforms()\n\n//         if (cc.sys.isNative) {\n//             cc.log(\"use native GLProgram\")\n//             // this._program.initWithString(_default_vert_no_mvp, _wave_v_frag);\n//             // this._program.link();\n//             // this._program.updateUniforms();\n//         } else {\n//             this._program.initWithVertexShaderByteArray(jipai_vert, jipai_frag);\n//             this._program.addAttribute(cc.macro.ATTRIBUTE_NAME_POSITION, cc.macro.VERTEX_ATTRIB_POSITION);\n//             this._program.addAttribute(cc.macro.ATTRIBUTE_NAME_COLOR, cc.macro.VERTEX_ATTRIB_COLOR);\n//             this._program.addAttribute(cc.macro.ATTRIBUTE_NAME_TEX_COORD, cc.macro.VERTEX_ATTRIB_TEX_COORDS);\n//             this._program.link()\n//             this._program.updateUniforms()\n//         }\n\n//         this._uniRatio = this._program.getUniformLocationForName(\"ratio\");\n//         this._uniRadius = this._program.getUniformLocationForName(\"radius\");\n\n\n//         // if (cc.sys.isNative) {\n//         //     var glProgram_state = cc.GLProgramState.getOrCreateWithGLProgram(this._program);\n//         //     glProgram_state.setUniformFloat( this._uniRadius, this._radius );\n//         //     glProgram_state.setUniformFloat( this._uniRatio, this._ratio );\n//         //     glProgram_state.setUniformFloat( this._uniWidth, this._width );\n//         // }else{\n//         //     this._program.setUniformLocationWith1f( this._uniRadius, this._radius );\n//         //     this._program.setUniformLocationWith1f( this._uniRatio, this._ratio );\n//         //     this._program.setUniformLocationWith1f( this._uniWidth, this._width );\n//         // }\n\n//         this.setProgram(this.node._sgNode, this._program);\n//     },\n//     setProgram: function (node, program) {\n//         if (cc.sys.isNative) {\n//             var glProgram_state = cc.GLProgramState.getOrCreateWithGLProgram(program);\n//             node.setGLProgramState(glProgram_state);\n//         } else {\n//             node.setShaderProgram(program);\n//         }\n\n//         var children = node.children;\n//         if (!children)\n//             return;\n\n//         for (var i = 0; i < children.length; i++)\n//             this.setProgram(children[i], program);\n//     },\n\n//     update: function (dt) {\n//         if (this._program) {\n//             this._program.use();\n//             if (cc.sys.isNative) {\n//                 var glProgram_state = cc.GLProgramState.getOrCreateWithGLProgram(this._program);\n//                 glProgram_state.setUniformFloat(this._uniRadius, this._radius);\n//                 glProgram_state.setUniformFloat(this._uniRatio, this._ratio);\n//                 glProgram_state.setUniformFloat(this._uniWidth, this._width);\n//             } else {\n//                 this._program.setUniformLocationWith1f(this._uniRadius, this._radius);\n//                 this._program.setUniformLocationWith1f(this._uniRatio, this._ratio);\n//                 this._program.setUniformLocationWith1f(this._uniWidth, this._width);\n//                 this._program.updateUniforms();\n//             }\n//         }\n//     },\n\n//     //通过图片取得纹理id，和该纹理在plist图中的纹理坐标范围\n//     getTextureAndRange: function (spriteFrame) {\n//         var tex = spriteFrame.getTexture()\n//         var id = tex.getName() //纹理ID\n\n//         //左右上下的纹理范围\n//         return [id, [0, 1, 0, 1], [tex.getContentSize().width, tex.getContentSize().height]]\n//     },\n\n//     initCardVertex: function (size, texRange, bFront) {\n//         var nDiv = 200 //将宽分成100份\n\n//         var verts = [] //位置坐标\n//         var texs = [] //纹理坐标\n//         var dh = size.height / nDiv\n//         var dw = size.width\n\n//         //计算顶点位置\n//         for (var c = 0; c < nDiv; c++) {\n//             var x = 0\n//             var y = (c - 1) * dh\n//             var quad = []\n//             if (bFront) {\n//                 quad = [x, y, x + dw, y, x, y + dh, x + dw, y, x + dw, y + dh, x, y + dh]\n//             } else {\n//                 quad = [x, y, x, y + dh, x + dw, y, x + dw, y, x, y + dh, x + dw, y + dh]\n//             }\n//             for (var i = 0; i < quad.length; i++) {\n//                 var v = quad[i]\n//                 verts.push(v)\n//             }\n//         }\n\n//         var bXTex = true //是否当前在计算横坐标纹理坐标，\n//         for (var i = 0; i < verts.length; i++) {\n//             if (bXTex) {\n//                 if (bFront) {\n//                     texs.push(texs, v / size.width * (texRange[1] - texRange[0]) + texRange[0])\n//                 } else {\n//                     texs.push(texs, v / size.width * (texRange[0] - texRange[1]) + texRange[1])\n//                 }\n//             } else {\n//                 if (bFront) {\n//                     texs.push(texs, (1 - v / size.height) * (texRange[3] - texRange[2]) + texRange[2])\n//                 } else {\n//                     texs.push(texs, v / size.height * (texRange[2] - texRange[3]) + texRange[3])\n//                 }\n//             }\n//             bXTex = !bXTex\n//         }\n\n//         var res = []\n//         var tmp = [verts, texs]\n//         for (var i = 0; i < tmp.length; i++) {\n//             var v = tmp[i];\n//             var buffid = gl.createBuffer()\n//             gl.bindBuffer(gl.ARRAY_BUFFER, buffid)\n//             gl.bufferData(gl.ARRAY_BUFFER, tableNums(v), v, gl.STATIC_DRAW)\n//             gl.bindBuffer(gl.ARRAY_BUFFER, 0)\n//             res.push(buffid)\n//         }\n//         return [res, tableNums(verts)]\n//     },\n\n// });\n"]}